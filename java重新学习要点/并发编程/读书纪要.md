# java并发编程的艺术

## 第一章：

* 相关工具：章节：1.1.2 
  * 使用Lmbench3[1]可以测量上下文切换的时长。 
  * 使用vmstat可以测量上下文切换的次数。
  * ![image-20210106092313553](C:\Users\17605\AppData\Roaming\Typora\typora-user-images\image-20210106092313553.png)



* 减少上下文切换的方法：
  * **无锁并发编程**：
    * 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁：将数据ID按照Hash算法取模分段，不同线程处理不同段的数据
  * **CAS算法**
    * java的 Atomic 包使用CAS算法来更新数据，而不需要加锁
  * **使用最小线程**
    * 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态
  * **协程**：
    * 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换



* 避免死锁的几个常见方法：
  * 避免一个线程同时获取多个锁
  * 尝试使用**定时锁**，使用 lock.tryLock(timeout) 来替代使用内部锁机制
  * 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

## 第二章 （后续需要仔细读，了解的是计算机的硬件） 

* volatile 是轻量级的 synchronized ，它在多处理器开发过程中保证了共享变量的 “可见性”。可见性是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

#### 2.3

* 原子（atomic）本意是："不能被进一步分割的最小粒子"
* 原子操作："不可被中断的一个或一系列操作"

 

## 第三章  Java内存模型（后续深入学习，基于硬件的底层内容）

* **通信**是指线程之间以**何种机制**来**交换信息**
  * 命令式编程中，，线程之间的通信机制有两种：**共享内存**和**消息传递**

* JMM 通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证
* 从java源代码到最终执行的指令序列，会分别经历下面3种重排序

![image-20210107092555163](C:\Users\17605\AppData\Roaming\Typora\typora-user-images\image-20210107092555163.png)

上述：1属于编译器重排序，2、3属于处理器重排序

* 这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的 

  顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作进行重排序。

* **为了保证内存可见性，java编译器在生成指令顺序的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序**

* 内存屏障类型表（后续学习）

* 

* 学习到 表 3-3 后续延此处进行学习 章节：3.1.4并发编程模型的分类

* **从JDK 5开始，Java使用新的JSR-133内存模型（除非特别说明，本文针对的都是JSR-133内**
  **存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。**  

### 3.2 重排序

* **重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段**

#### 3.2.1 数据依赖性

* **如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。**
* 数据依赖类型表

![image-20210111090318683](C:\Users\17605\AppData\Roaming\Typora\typora-user-images\image-20210111090318683.png)

* **编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行吮吸**

* 这里所说的数据依赖性仅针对单个处理器执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑

#### 3.2.1 as-if-serial 语义

* as-if-serial 语义的意思：**不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。**

#### 3.2.2 重排序对多线程的影响

* **现在让我们来看看，重排序是否会改变多线程程序的执行结果  **

```java
/**
 * @author yjl
 * @version $Id: ReorderExample.java, v 0.1 2021-01-11 9:27 yjl Exp $$
 */
public class ReorderExample {
    private int a = 0;
    private Boolean flag = false;

    public void writer(){
        a = 3;
        flag = true;
        System.out.println(flag +"========"+ a);
    }

    public void reader(){
       if(flag){
           a = a * a;
           System.out.println(flag +"========"+ a);
           return;
       }
        System.out.println(flag +"========"+ a);
    }

    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            final ReorderExample reorderExample = new ReorderExample();

            new Thread(new Runnable() {
                public void run() {
                    reorderExample.writer();
                    System.out.println(Thread.currentThread().getName());
                }
            }).start();

            new Thread(new Runnable() {
                public void run() {
                    reorderExample.reader();
                    System.out.println(Thread.currentThread().getName());
                }
            }).start();
        }

    }
}
```

* 执行结果中存在：

* ```tex
  Thread-142
  true========9
  Thread-143
  false========0
  Thread-145
  true========3
  Thread-144
  true========3
  ```

* **在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作重排序的原因）；**

* **单在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。**

### 3.3 顺序一致性

* **顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性模型作为参照**；

#### 3.3.1数据竞争与顺序一致性

* **当程序未正确同步时，就可能存在数据竞争**
* **如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序**
* **如果多线程程序是正确同步的，程序执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。**
  * **这里的同步是指广义上的同步，包括对常用同步原语（synchronized、volatile和final）的正确使用**

#### 3.3.2 顺序一致性模型

* 顺序一致性模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。
* **内存一致性模型两大特征：**
  * **一个线程中的所有操作必须按照程序的顺序来执行**
  * **（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见；**

#### 3.3.3 同步程序顺序一致性效果

* **对前面的示例程序ReorderExample用锁来同步，看看正确同步的程序如何具有顺序一致性

#### 3.3.4 未同步程序的执行特性

* JMM 最小安全性
* **JMM 不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致；**
* 

### 3.4 volatile 的内存语义

* **当声明共享变量未volatile后，对这个变量的读/写将会很特别。**

#### 3.4.1 volatile的特性

* **理解volatile特性的一个好方法是把对volatile变量的单个读写，看成是使用同一个锁对这些单个读/写操作做了同步；**
* volatile变量自身具有以下特性。
  * **可见性**：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入；
  * **原子性**：对任意单个volatile变量的读/写具有原子性。单类似与volatile++ 这种复合操作不具有原子性



#### 3.4.3 volatile写-读的内存语义

* volatile写的内存语义：
  * **当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。**
* volatile读的内存语义：
  * **当读一个volatile变量时，JMM会把该线程对应的本地内存设置未无效。线程接下来将从主内存中读取共享变量。**
* volatile写和volatile读的内存语义做个总结：
  * **线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程**
    **发出了（其对共享变量所做修改的）消息。**
  * **线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile**
    **变量之前对共享变量所做修改的）消息。**
  * **线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过**
    **主内存向线程B发送消息。**  

### **3.5 锁的内存语义**

* 众所周知，锁可以让临界区互斥执行。  （**临界区就是在同一时刻只能有一个任务访问的代码区**）
* 



## 第四章 Java并发编程基础（实践，目前重点）

### 4.1 什么是线程：

* **现在操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程中可以创建多个线程。这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。**

* ```java
  public class MultiThread {
  
      public static void main(String[] args) {
          // 获取java线程管理者MXBean
          ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
          // 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息
          ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
          Arrays.stream(threadInfos).forEach(threadInfo -> {
              System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.
                  getThreadName());
          });
      }
  
  }
  ```

* ```json
  [6] Monitor Ctrl-Break
  [5] Attach Listener
  [4] Signal Dispatcher
  [3] Finalizer
  [2] Reference Handler
  [1] main
  ```

* 可以看到，一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其他线
  程的同时运行。  

#### 4.1.2 为什么要使用多线程

* 更多的处理器核心
* 更快的响应时间
* 更好的编程模型



#### 4.1.3 线程优先级

* **线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性**  

#### 4.1.4 线程的状态

* ![image-20210112145313670](C:\Users\17605\AppData\Roaming\Typora\typora-user-images\image-20210112145313670.png)

* **线程创建之后，调用start()方法开始运行。**
* **当线程执行wait()方法之后，线程进入等待状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态**
* **超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。**
* **当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。**  

#### 4.1.5 Deamon线程（守护线程）

* Deamon线程是一种支持线程，因为它的主要被用作**程序中后台调度**以及**支持性工作**。这意味着，当一个java虚拟机中不存在非Deamon线程的时候，java虚拟机将会退出。
* **可以通过调用 Thread.setDaemon(true);将线程设置成Deamon线程。**
* **注意：Daemon属性需要在启动线程之前设置，不能在启动线程之后设置**  

* **Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行**  

* ```java
  /**
   * Deamon 守护线程特性
   * Deamon 线程被用作完成支持工作，但是在java虚拟机退出时Deamon线程中的finally块 并不一定执行。
   * 以下是示例代码
   * @author yjl
   * @version $Id: Deamon.java, v 0.1 2021-01-12 15:28 yjl Exp $$
   */
  public class Deamon {
      public static void main(String[] args) {
          Thread deamonRunner = new Thread(new DeamonRunner(), "DeamonRunner");
          deamonRunner.setDaemon(true);
          deamonRunner.start();
      }
  
      static class DeamonRunner implements Runnable{
  
          @Override
          public void run() {
              try {
                  TimeUnit.SECONDS.sleep(10);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              } finally {
                  System.out.println("DeamonThread finally run.");
              }
          }
      }
  }
  ```

* **运行Daemon程序，可以看到在终端或者命令提示符上没有任何输出**  

* **在构建Deamon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑；**



### 4.2 启动和终止线程

