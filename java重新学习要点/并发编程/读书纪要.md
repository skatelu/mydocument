# java并发编程的艺术

### 第一章：

* 相关工具：章节：1.1.2 
  * 使用Lmbench3[1]可以测量上下文切换的时长。 
  * 使用vmstat可以测量上下文切换的次数。
  * ![image-20210106092313553](C:\Users\17605\AppData\Roaming\Typora\typora-user-images\image-20210106092313553.png)



* 减少上下文切换的方法：
  * **无锁并发编程**：
    * 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁：将数据ID按照Hash算法取模分段，不同线程处理不同段的数据
  * **CAS算法**
    * java的 Atomic 包使用CAS算法来更新数据，而不需要加锁
  * **使用最小线程**
    * 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态
  * **协程**：
    * 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换



* 避免死锁的几个常见方法：
  * 避免一个线程同时获取多个锁
  * 尝试使用**定时锁**，使用 lock.tryLock(timeout) 来替代使用内部锁机制
  * 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

### 第二章 （后续需要仔细读，了解的是计算机的硬件） 

* volatile 是轻量级的 synchronized ，它在多处理器开发过程中保证了共享变量的 “可见性”。可见性是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

#### 2.3

* 原子（atomic）本意是："不能被进一步分割的最小粒子"
* 原子操作："不可被中断的一个或一系列操作"

 

### 第三章  Java内存模型

* **通信**是指线程之间以**何种机制**来**交换信息**
  * 命令式编程中，，线程之间的通信机制有两种：**共享内存**和**消息传递**

* JMM 通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证
* 从java源代码到最终执行的指令序列，会分别经历下面3种重排序

![image-20210107092555163](C:\Users\17605\AppData\Roaming\Typora\typora-user-images\image-20210107092555163.png)

上述：1属于编译器重排序，2、3属于处理器重排序

* 这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的 

  顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作进行重排序。

* **为了保证内存可见性，java编译器在生成指令顺序的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序**

* 内存屏障类型表（后续学习）

* 

* 学习到 表 3-3 后续延此处进行学习 章节：3.1.4并发编程模型的分类

* **从JDK 5开始，Java使用新的JSR-133内存模型（除非特别说明，本文针对的都是JSR-133内**
  **存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。**  

### 3.2 重排序

* **重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段**

#### 3.2.1 数据依赖性

* **如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。**
* 数据依赖类型表

![image-20210111090318683](C:\Users\17605\AppData\Roaming\Typora\typora-user-images\image-20210111090318683.png)

* **编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行吮吸**

* 这里所说的数据依赖性仅针对单个处理器执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑

#### 3.2.1 as-if-serial 语义

* as-if-serial 语义的意思：**不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。**

#### 3.2.2 重排序对多线程的影响

* **现在让我们来看看，重排序是否会改变多线程程序的执行结果  **

```java
/**
 * @author yjl
 * @version $Id: ReorderExample.java, v 0.1 2021-01-11 9:27 yjl Exp $$
 */
public class ReorderExample {
    private int a = 0;
    private Boolean flag = false;

    public void writer(){
        a = 3;
        flag = true;
        System.out.println(flag +"========"+ a);
    }

    public void reader(){
       if(flag){
           a = a * a;
           System.out.println(flag +"========"+ a);
           return;
       }
        System.out.println(flag +"========"+ a);
    }

    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            final ReorderExample reorderExample = new ReorderExample();

            new Thread(new Runnable() {
                public void run() {
                    reorderExample.writer();
                    System.out.println(Thread.currentThread().getName());
                }
            }).start();

            new Thread(new Runnable() {
                public void run() {
                    reorderExample.reader();
                    System.out.println(Thread.currentThread().getName());
                }
            }).start();
        }

    }
}
```

* 执行结果中存在：

* ```tex
  Thread-142
  true========9
  Thread-143
  false========0
  Thread-145
  true========3
  Thread-144
  true========3
  ```

* **在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作重排序的原因）；**

* **单在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。**

### 3.3 顺序一致性

* **顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性模型作为参照**；

#### 3.3.1数据竞争与顺序一致性

* **当程序未正确同步时，就可能存在数据竞争**
* **如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序**
* **如果多线程程序是正确同步的，程序执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。**
  * **这里的同步是指广义上的同步，包括对常用同步原语（synchronized、volatile和final）的正确使用**

#### 3.3.2 顺序一致性模型

* 顺序一致性模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。
* **内存一致性模型两大特征：**
  * **一个线程中的所有操作必须按照程序的顺序来执行**
  * **（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见；**

#### 3.3.3 同步程序顺序一致性效果

* **对前面的示例程序ReorderExample用锁来同步，看看正确同步的程序如何具有顺序一致性