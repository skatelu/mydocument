## java 悲观锁的实现方式
#### 像 synchronized 关键字实现的就是悲观锁
* 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

## java 乐观锁的实现方式
#### Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
* 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。


### 乐观锁的一种实现方式-CAS(Compare and Swap 比较并交换)：
* 是通过 compareAndSet 这个方法 利用JNI来完成CPU指令的操作。
* 缺点
  * 这种实现方式会导致 ABA 问题 具体详情参考 https://blog.csdn.net/caisongcheng_good/article/details/79916873

### 乐观锁的另一种实现方式：版本号机制
* 表设计时，需要往表里加一个version字段。每次查询时，查出带有version的数据记录，更新数据时，判断数据库里对应id的记录的version是否和查出的version相同。若相同，则更新数据并把版本号+1；若不同，则说明，该数据发送并发，被别的线程使用了，进行递归操作，再次执行递归方法，知道成功更新数据为止

